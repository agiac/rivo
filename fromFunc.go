package rivo

import (
	"context"
	"errors"
	"fmt"
	"sync"
)

var ErrEOS = errors.New("end of stream")

// FromFunc returns a generator Pipeline that emits items generated by the given function. The input stream is ignored.
// The returned stream will emit items until the function returns ErrEOS.
func FromFunc[T any](f func(context.Context) (T, error), options ...FromFuncOption) Pipeline[None, T] {
	o := mustFromFuncOptions(options)

	return func(ctx context.Context, _ Stream[None]) Stream[T] {
		out := make(chan Item[T], o.bufferSize)

		go func() {
			defer close(out)
			defer beforeClose(ctx, out, o.onBeforeClose)

			wg := sync.WaitGroup{}
			wg.Add(o.poolSize)

			for i := 0; i < o.poolSize; i++ {
				go func() {
					defer wg.Done()

					for {
						v, err := f(ctx)
						if errors.Is(err, ErrEOS) {
							return
						}

						select {
						case <-ctx.Done():
							out <- Item[T]{Err: ctx.Err()}
							return
						default:
							out <- Item[T]{Val: v, Err: err}
						}
					}
				}()
			}

			wg.Wait()
		}()

		return out
	}
}

type fromFuncOptions struct {
	poolSize      int
	bufferSize    int
	onBeforeClose func(context.Context) error
}

type FromFuncOption func(*fromFuncOptions) error

func FromFuncPoolSize(poolSize int) FromFuncOption {
	return func(o *fromFuncOptions) error {
		if poolSize < 1 {
			return errors.New("poolSize must be greater than 0")
		}
		o.poolSize = poolSize
		return nil
	}
}

func FromFuncBufferSize(bufferSize int) FromFuncOption {
	return func(o *fromFuncOptions) error {
		if bufferSize < 0 {
			return errors.New("bufferSize must be greater than or equal to 0")
		}
		o.bufferSize = bufferSize
		return nil
	}
}

func FromFuncOnBeforeClose(f func(context.Context) error) FromFuncOption {
	return func(o *fromFuncOptions) error {
		if f == nil {
			return errors.New("onBeforeClose must not be nil")
		}
		o.onBeforeClose = f
		return nil
	}
}

var defaultFromFuncOptions = fromFuncOptions{
	poolSize:   1,
	bufferSize: 0,
}

func applyFromFuncOptions(opts []FromFuncOption) (*fromFuncOptions, error) {
	o := &defaultFromFuncOptions
	for _, opt := range opts {
		if err := opt(o); err != nil {
			return nil, err
		}
	}
	return o, nil
}

func mustFromFuncOptions(opts []FromFuncOption) *fromFuncOptions {
	o, err := applyFromFuncOptions(opts)
	if err != nil {
		panic(fmt.Sprintf("invalid FromFuncOption: %v", err))
	}
	return o
}
