package rivo

import (
	"context"
	"errors"
	"fmt"
	"sync"
)

// TODO: the function could take the error channel as an argument to report errors, so as other generators.

// FromFunc returns a Generator that emits items generated by the given function.
// The returned stream will emit items until the function returns false in the second return value.
func FromFunc[T any](f func(context.Context) (T, bool), options ...FromFuncOption) Generator[T] {
	o := mustFromFuncOptions(options)

	return func(ctx context.Context, _ Stream[None], errs chan<- error) Stream[T] {
		out := make(chan T, o.bufferSize)

		go func() {
			defer close(out)
			defer o.onBeforeClose(ctx)

			wg := sync.WaitGroup{}
			wg.Add(o.poolSize)

			for i := 0; i < o.poolSize; i++ {
				go func() {
					defer wg.Done()

					for {
						v, ok := f(ctx)
						if !ok {
							return
						}

						select {
						case <-ctx.Done():
							return
						case out <- v:
						}
					}
				}()
			}

			wg.Wait()
		}()

		return out
	}
}

type fromFuncOptions struct {
	poolSize      int
	bufferSize    int
	onBeforeClose func(context.Context)
}

type FromFuncOption func(*fromFuncOptions) error

func FromFuncPoolSize(poolSize int) FromFuncOption {
	return func(o *fromFuncOptions) error {
		if poolSize < 1 {
			return errors.New("poolSize must be greater than 0")
		}
		o.poolSize = poolSize
		return nil
	}
}

func FromFuncBufferSize(bufferSize int) FromFuncOption {
	return func(o *fromFuncOptions) error {
		if bufferSize < 0 {
			return errors.New("bufferSize must be greater than or equal to 0")
		}
		o.bufferSize = bufferSize
		return nil
	}
}

func FromFuncOnBeforeClose(f func(context.Context)) FromFuncOption {
	return func(o *fromFuncOptions) error {
		if f == nil {
			return errors.New("onBeforeClose must not be nil")
		}
		o.onBeforeClose = f
		return nil
	}
}

func newDefaultFromFuncOptions() *fromFuncOptions {
	return &fromFuncOptions{
		poolSize:      1,
		bufferSize:    0,
		onBeforeClose: func(ctx context.Context) {},
	}
}

func applyFromFuncOptions(opts []FromFuncOption) (*fromFuncOptions, error) {
	o := newDefaultFromFuncOptions()
	for _, opt := range opts {
		if err := opt(o); err != nil {
			return nil, err
		}
	}
	return o, nil
}

func mustFromFuncOptions(opts []FromFuncOption) *fromFuncOptions {
	o, err := applyFromFuncOptions(opts)
	if err != nil {
		panic(fmt.Sprintf("invalid FromFuncOption: %v", err))
	}
	return o
}
